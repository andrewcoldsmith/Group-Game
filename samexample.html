<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Sam's Example</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
        
        <canvas id="bg"></canvas>
		<script src="./three.js"></script>
		<script>
			const speed = 0.5
            const sphereCount = 1;
            let spheres = [];
            let x = [];
            let y = [];
            let z = [];
            let hue = [];
            for (let i = 0; i < sphereCount; i++) {
            x.push(Math.random() < 0.5 ? -speed : speed);
            y.push(Math.random() < 0.5 ? -speed : speed);
            z.push(Math.random() < 0.5 ? -speed : speed);
            }
            for (let i = 0; i < sphereCount; i++) {
            hue.push(Math.trunc(Math.random() * 1000) / 1000);
            }
            let radius = 6;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth  / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg'),
            });

            renderer.shadowMap.enabled = true;

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.position.setZ(45);

            renderer.render(scene, camera);

            const ambLight = new THREE.AmbientLight(0x404040);
            scene.add(ambLight);
  
            // Add hemisphere lighting.
            const hemisphereLight = new THREE.HemisphereLight( 0x32a852, 0xffffff, 0.5 );
            scene.add( hemisphereLight );

            const pointLight = new THREE.PointLight(0xffffff, 1, 700);
            pointLight.position.set(35, 10, 40);
            pointLight.castShadow = true;
            scene.add(pointLight);

            pointLight.shadow.mapSize.width = 712;
            pointLight.shadow.mapSize.height = 712;
            pointLight.shadow.camera.near = 7;
            pointLight.shadow.camera.far = 500;

            //Sam's Golf Ball
            const bigSphereGeo = new THREE.SphereGeometry(2, 32, 16);
            const bigSphereMat = new THREE.MeshPhongMaterial({
                color: 0xffffff, wireframe: false});
            const bigSphere = new THREE.Mesh(bigSphereGeo, bigSphereMat);
            bigSphere.castShadow = true;
            bigSphere.receiveShadow = true;
            bigSphere.position.x = 0;
            bigSphere.position.y = 0;
            bigSphere.position.z = 0;
            scene.add(bigSphere);

            //Sam's blue donut
            const donutGeo = new THREE.TorusGeometry(10, 6, 30, 50);
            const donutMat = new THREE.MeshPhongMaterial({
                color: 0x3373ab, wireframe: false});
            const donut = new THREE.Mesh(donutGeo, donutMat);
            donut.rotateX(Math.PI/6);
            donut.rotateY(Math.PI/3);
            donut.castShadow = true;
            donut.receiveShadow = true;
            donut.position.x = -30;
            donut.position.y = 0;
            donut.position.z = -15;
            scene.add(donut);

            //Sam's green cylinder
            const cylinderGeo = new THREE.CylinderGeometry(10, 1, 14, 50, 2);
            const cylinderMat = new THREE.MeshPhongMaterial({
                color: 0x207a1d, wireframe: false});
            const cylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
            // cylinder.rotateX(Math.PI/6);
            // cylinder.rotateY(Math.PI/6);
            cylinder.rotateZ(Math.PI/6);
            cylinder.castShadow = true;
            cylinder.receiveShadow = true;
            cylinder.position.x = 30;
            cylinder.position.y = -15;
            cylinder.position.z = -10;
            scene.add(cylinder);

            const plane1Geo = new THREE.PlaneGeometry(50 + (2 * radius), 36 + (2 * radius));
            const plane1Mat = new THREE.MeshPhongMaterial({
            color: 0x7c7d80, side: THREE.DoubleSide, wireframe: false});
            const plane1 = new THREE.Mesh(plane1Geo, plane1Mat);
            plane1.receiveShadow = true;
            plane1.rotateY(Math.PI / 2);
            plane1.position.x = -(40 + radius);
            scene.add(plane1);

            const plane2Geo = new THREE.PlaneGeometry(50 + (2 * radius), 36 + (2 * radius));
            const plane2Mat = new THREE.MeshPhongMaterial({
            color: 0x7c7d80, side: THREE.DoubleSide, wireframe: false});
            const plane2 = new THREE.Mesh(plane2Geo, plane2Mat);
            plane2.receiveShadow = true;
            plane2.rotateY(Math.PI / 2);
            plane2.position.x = 40 + radius;
            scene.add(plane2);

            const plane3Geo = new THREE.PlaneGeometry(80 + (2 * radius), 36 + (2 * radius));
            const plane3Mat = new THREE.MeshPhongMaterial({
            color: 0x7c7d80, side: THREE.DoubleSide, wireframe: false});
            const plane3 = new THREE.Mesh(plane3Geo, plane3Mat);
            plane3.receiveShadow = true;
            plane3.position.z = -(25 + radius);
            scene.add(plane3);

            const plane4Geo = new THREE.PlaneGeometry(80 + (2 * radius), 50 + (2 * radius));
            const plane4Mat = new THREE.MeshPhongMaterial({
            color: 0x7c7d80, side: THREE.DoubleSide, wireframe: false});
            const plane4 = new THREE.Mesh(plane4Geo, plane4Mat);
            plane4.receiveShadow = true;
            plane4.rotateX(Math.PI / 2);
            plane4.position.y = -(18 + radius);
            scene.add(plane4);

            const plane5Geo = new THREE.PlaneGeometry(80 + (2 * radius), 50 + (2 * radius));
            const plane5Mat = new THREE.MeshPhongMaterial({
            color: 0x7c7d80, side: THREE.DoubleSide, wireframe: false});
            const plane5 = new THREE.Mesh(plane5Geo, plane5Mat);
            plane5.receiveShadow = true;
            plane5.rotateX(Math.PI / 2);
            plane5.position.y = 18 + radius;
            scene.add(plane5);

            const sphereGeo = new THREE.SphereGeometry(radius, 32, 16);
            const sphereMat1 = new THREE.MeshPhongMaterial({wireframe: false});
            const sphere1 = new THREE.Mesh(sphereGeo, sphereMat1);
            sphere1.material.color.setHSL(hue[0], 1, 0.5);
            sphere1.castShadow = true;
            sphere1.receiveShadow = true;
            spheres.push(sphere1);
            sphere1.position.x = -30;
            sphere1.position.y = 12;
            sphere1.position.z = -18;
            scene.add(sphere1);

            renderer.render(scene, camera);

            function animate() {
            requestAnimationFrame(animate);

            for (let i = 0; i < sphereCount; i++) {

                //Set movement
                spheres[i].position.x += x[i];
                spheres[i].position.y += y[i];
                spheres[i].position.z += z[i];
                

                // Collision with outside walls
                if (spheres[i].position.x > 40) {
                x[i] = -speed;
                }
                if (spheres[i].position.x < -40) {
                x[i] = speed;
                }
                if (spheres[i].position.y > 18) {
                y[i] = -speed;
                }
                if (spheres[i].position.y < -18) {
                y[i] = speed;
                }
                if (spheres[i].position.z > 25) {
                z[i] = -speed;
                }
                if (spheres[i].position.z < -25) {
                z[i] = speed;
                }
            }

            renderer.render(scene, camera);
            }

            animate();
		</script>
	</body>
</html>